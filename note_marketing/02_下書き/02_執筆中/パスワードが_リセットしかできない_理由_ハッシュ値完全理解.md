# パスワードが「リセットしかできない」理由：ハッシュ値完全理解

---

**ゲーム開発のご相談：**
https://ryuryugame.netlify.app/

**AI観光ガイドの導入：**
https://guidecastai.netlify.app/

---

## なぜサービス会社は「あなたのパスワードはXXXです」と教えてくれないのか

GitHubでパスワードを忘れた時、「パスワードを表示」ではなく「リセット用リンク」が送られてきます。

Google、Facebook、X（旧Twitter）...どこも同じ。

**なぜ「あなたのパスワードは『password123』です」と教えてくれないのでしょうか？**

答え：**サービス側もあなたのパスワードを知らないから**です。

## まともなサービスがパスワードを「生で」保存しない理由

### データベースハッキングのリスク

もしサービスがパスワードをそのまま保存していたら：

```sql
-- 危険な保存方法
users テーブル:
id | username | password
1  | yamada   | password123
2  | tanaka   | mypassword
3  | sato     | 123456
```

ハッカーがデータベースにアクセスした瞬間、**全ユーザーのパスワードが丸見え**になります。

### 内部犯行のリスク

社員や管理者でも、ユーザーのパスワードは見られない方が安全です。

「ちょっと有名人のアカウント覗いてみよう」という誘惑を技術的に防ぐことができます。

## ハッシュ値という「一方通行の変換」

### ハッシュ値の基本概念

ハッシュ化は「元に戻せない変換」です。

```
「password123」→ ハッシュ化 → 「ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f」
```

この64文字の文字列から、元の「password123」を復元することは**技術的に不可能**です。

### 実際のデータベース構造

```sql
-- 安全な保存方法
users テーブル:
id | username | password_hash
1  | yamada   | ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
2  | tanaka   | a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3
3  | sato     | 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
```

ハッカーがこのデータを盗んでも、元のパスワードは分からない。

## ハッシュ値の3つの重要な特徴

### 1. 一方通行（不可逆性）

```
入力 → ハッシュ化 → 出力
❌ 出力 → 逆変換 → 入力（不可能）
```

**例：**
- `password123` → `ef92b778...`（可能）
- `ef92b778...` → `password123`（不可能）

### 2. 同じ入力は常に同じ出力

```
SHA-256("password123") = ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f

何回計算しても同じ結果が得られる
```

この特性により、ログイン時の認証が可能になります。

### 3. 少しでも違う入力なら全く違う出力

```
SHA-256("password123") = ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
SHA-256("password124") = 8bb6118f8fd6935ad0876a3be34a717d32708ffd9a2ba6561d2ae2c4b6d5d8e5
```

1文字変わっただけで、全く違うハッシュ値になります。

## ログイン認証の仕組み

### 新規登録時

```csharp
// ユーザーが入力したパスワード
string userPassword = "password123";

// ハッシュ化してデータベースに保存
string hashedPassword = ComputeSHA256Hash(userPassword);
SaveToDatabase(username, hashedPassword);
```

### ログイン時

```csharp
// ユーザーが入力したパスワード
string inputPassword = "password123";

// 入力パスワードをハッシュ化
string inputHash = ComputeSHA256Hash(inputPassword);

// データベースのハッシュ値と比較
string storedHash = GetFromDatabase(username);
if (inputHash == storedHash)
{
    // ログイン成功
}
```

## 危険なハッシュアルゴリズムと安全なもの

### ❌ MD5：使ってはいけない

```csharp
MD5("password123") = "482c811da5d5b4bc6d497ffa98491e38"
```

**問題点：**
- 32文字と短い
- 高速すぎる（総当たり攻撃に弱い）
- 「衝突」が発見されている

### ❌ SHA-1：既に危険

```csharp
SHA1("password123") = "f4e1bb6bb74e1dd5ed3860cb0bdc84c5b4fa1bb6"
```

**問題点：**
- Googleが2017年に衝突攻撃に成功
- 段階的に廃止が進んでいる

### ⭕ SHA-256：現在の推奨

```csharp
SHA256("password123") = "ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f"
```

**利点：**
- 64文字と長い
- 現時点で衝突が発見されていない
- 計算コストが適度

### ⭕⭕ bcrypt/scrypt/Argon2：最も安全

```csharp
bcrypt("password123", cost=12) = "$2b$12$EXRKDmm1JkdwUDIKRgN3X.Z3.ZV8fZN5/a8M7XJ0K.V9/BHM2mGJC"
```

**特徴：**
- 意図的に計算時間を長くしている
- 総当たり攻撃を困難にする
- コストパラメーターで強度を調整可能

## Unityでの実装例

### SHA-256を使った基本実装

```csharp
using System;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

public class PasswordManager : MonoBehaviour
{
    public string HashPassword(string password)
    {
        using (SHA256 sha256 = SHA256.Create())
        {
            byte[] inputBytes = Encoding.UTF8.GetBytes(password);
            byte[] hashBytes = sha256.ComputeHash(inputBytes);

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < hashBytes.Length; i++)
            {
                sb.Append(hashBytes[i].ToString("x2"));
            }
            return sb.ToString();
        }
    }

    public bool VerifyPassword(string inputPassword, string storedHash)
    {
        string inputHash = HashPassword(inputPassword);
        return string.Equals(inputHash, storedHash, StringComparison.OrdinalIgnoreCase);
    }
}
```

### より安全な実装（ソルト付き）

```csharp
public class SecurePasswordManager : MonoBehaviour
{
    public string HashPasswordWithSalt(string password, out string salt)
    {
        // ランダムなソルトを生成
        salt = GenerateRandomSalt();

        // パスワードとソルトを結合してハッシュ化
        string saltedPassword = password + salt;
        return HashPassword(saltedPassword);
    }

    private string GenerateRandomSalt()
    {
        byte[] saltBytes = new byte[32];
        using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())
        {
            rng.GetBytes(saltBytes);
        }
        return Convert.ToBase64String(saltBytes);
    }

    public bool VerifyPasswordWithSalt(string inputPassword, string storedHash, string storedSalt)
    {
        string saltedPassword = inputPassword + storedSalt;
        string inputHash = HashPassword(saltedPassword);
        return inputHash == storedHash;
    }
}
```

## ソルトの重要性

### ソルトなしの危険性

同じパスワードを使うユーザーが複数いると：

```
user1: password123 → ef92b778bafe...
user2: password123 → ef92b778bafe...  ←同じハッシュ値！
user3: password123 → ef92b778bafe...  ←これも同じ！
```

ハッカーは「同じハッシュ値のユーザーは同じパスワード」と分かってしまいます。

### ソルト付きの安全性

```
user1: password123 + random_salt_1 → a1b2c3d4e5f6...
user2: password123 + random_salt_2 → x7y8z9a0b1c2...  ←異なるハッシュ値
user3: password123 + random_salt_3 → m3n4o5p6q7r8...  ←これも異なる
```

同じパスワードでも、異なるソルトにより異なるハッシュ値になります。

## レインボーテーブル攻撃の対策

### レインボーテーブルとは

よく使われるパスワードとそのハッシュ値を事前に計算したテーブル：

```
password123 → ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
123456      → 8bb6118f8fd6935ad0876a3be34a717d32708ffd9a2ba6561d2ae2c4b6d5d8e5
qwerty      → 65e84be33532fb784c48129675f9eff3a682b27168c0ea744b2cf58ee02337c5
```

### ソルトによる防御

ソルト付きハッシュは、レインボーテーブルを無効化します：

```
password123 + salt_abc → 完全に新しいハッシュ値
```

ハッカーは、各ユーザーの各ソルトに対して個別にテーブルを作る必要があり、現実的ではありません。

## ChatGPTとの効果的な質問例

### Before（曖昧な質問）
「パスワードを安全に保存したいです。」

### After（具体的な質問）
「Unity+C#で、ユーザーパスワードをSHA-256でハッシュ化して保存したいです。ソルトも使用したいのですが、ソルトの生成方法と保存方法、ログイン時の照合処理の実装例を教えてください。」

## まとめ：なぜこの知識が重要なのか

1. **セキュリティ意識の向上**
   - パスワード管理の仕組みを理解
   - 危険な実装を回避

2. **ChatGPTとの協業効率化**
   - 「認証システム作って」→「bcryptを使ったパスワードハッシュ化システム作って」
   - より具体的で安全なコード生成

3. **トラブル時の問題解決**
   - ログイン失敗の原因を特定
   - 適切なデバッグ方法の選択

4. **国際標準への準拠**
   - GDPR、個人情報保護法への対応
   - 業界標準のセキュリティ実装

「パスワードをそのまま保存してはいけない」理由が分かれば、セキュアなアプリケーション開発の第一歩を踏み出せます。

---

**ゲーム開発のご相談：**
https://ryuryugame.netlify.app/

**AI観光ガイドの導入：**
https://guidecastai.netlify.app/

---